from .base_repo import BaseRepository
from models import Order
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload



class OrderRepository(BaseRepository):
    """
    Repository for Order model. Handles all database operations related to orders.
    All methods are asynchronous and expect an async SQLAlchemy session.
    """

    def __init__(self, session):
        """
        Initialize repository with a database session.
        :param session: Async SQLAlchemy session
        """
        self.session = session

    async def create(self, obj: Order) -> Order:
        """
        Add a new order to the database.
        Commits and refreshes the object to get updated fields (e.g., autogenerated ID).
        :param obj: Order instance
        :return: Created Order instance
        """
        self.session.add(obj)
        await self.session.commit()
        await self.session.refresh(obj)
        return obj
    
    
    
    async def get_by_id(self, order_id: int) -> Order:
        result = await self.session.execute(
            select(Order)
            .options(selectinload(Order.order_items))  # eager-load order_items
            .where(Order.id == order_id)
        )
        return result.scalars().first()
    
    async def get_all(self) -> list[Order]:
        """
        Retrieve all orders from the database.
        :return: List of Order instances
        """
        result = await self.session.execute(select(Order).options(selectinload(Order.order_items))) 
        return result.scalars().all()
        
    async def update(self, id: int, update_data: dict) -> Order:
        """
        Update an existing order with the provided data.
        :param id: Order ID
        :param update_data: Dictionary of fields to update
        :return: Updated Order instance or None if not found
        Note: update_data should be a dict, not an Order model instance.
        """
        existing_order = await self.get_by_id(id)
        if not existing_order:
            return None
        for key, value in update_data.items():
            setattr(existing_order, key, value)

        self.session.add(existing_order)
        await self.session.commit()
        await self.session.refresh(existing_order)
        return existing_order
    
    async def delete(self, id: int) -> bool:
        """
        Delete an order by its ID.
        :param id: Order ID
        :return: True if deleted, False if not found
        """
        existing_order = await self.get_by_id(id)
        if not existing_order:
            return False
        await self.session.delete(existing_order)
        await self.session.commit()
        return True