from .base_repo import BaseRepository
from models import Product
from sqlalchemy.future import select
from schema.products import ProductFiltering



class ProductRepository(BaseRepository):
    """
    Repository for Product model. Handles all database operations related to products.
    All methods are asynchronous and expect an async SQLAlchemy session.
    """

    def __init__(self, session):
        """
        Initialize repository with a database session.
        :param session: Async SQLAlchemy session
        """
        self.session = session

    async def create(self, obj: Product) -> Product:
        """
        Add a new product to the database.
        Commits and refreshes the object to get updated fields (e.g., autogenerated ID).
        :param obj: Product instance
        :return: Created Product instance
        """
        self.session.add(obj)
        await self.session.commit()
        await self.session.refresh(obj)
        return obj
    
    async def get_by_id(self, id: int) -> Product:
        """
        Retrieve a product by its ID.
        :param id: Product ID
        :return: Product instance or None if not found
        """
        result = await self.session.get(Product, id)
        return result
    
    async def get_product_by_name(self, name: str) -> Product:
        """
        Retrieve a product by its name.
        :param name: Product name
        :return: Product instance or None if not found
        """
        result = await self.session.execute(
            select(Product).where(Product.name == name)
        )
        return result.scalars().first()
    
    async def get_all(self) -> list[Product]:
        """
        Retrieve all products from the database.
        :return: List of Product instances
        """
        result = await self.session.execute(select(Product))
        return result.scalars().all()

    async def fetch_filtered(self, filters: ProductFiltering) -> list[Product]:
        """
        Retrieve products based on filtering criteria.
        :param filters: ProductFiltering instance with optional filter fields
        :return: List of Product instances matching the filters
        """
        query = select(Product)

        if filters.name:
            query = query.where(Product.name.ilike(f"%{filters.name}%"))
        if filters.min_price is not None:
            query = query.where(Product.price >= filters.min_price)
        if filters.max_price is not None:
            query = query.where(Product.price <= filters.max_price)
        if filters.category_id is not None:
            query = query.where(Product.category_id == filters.category_id)

        result = await self.session.execute(query)
        return result.scalars().all()
    
    async def update(self, id: int, update_data: dict) -> Product:
        """
        Update an existing product with the provided data.
        :param id: Product ID
        :param update_data: Dictionary of fields to update
        :return: Updated Product instance or None if not found
        Note: update_data should be a dict, not a Product model instance.
        """
        existing_product = await self.get_by_id(id)
        if not existing_product:
            return None
        for key, value in update_data.items():
            setattr(existing_product, key, value)
        self.session.add(existing_product)
        await self.session.commit()
        await self.session.refresh(existing_product)
        return existing_product
    
    async def delete(self, id: int) -> bool:
        """
        Delete a product by its ID.
        :param id: Product ID
        :return: True if deleted, False if not found
        """
        existing_product = await self.get_by_id(id)
        if not existing_product:
            return False
        await self.session.delete(existing_product)
        await self.session.commit()
        return True